---
title: "Building Option Pricing System in C++ #01"
date: 2019-02-20
tags: [programming, quantitative finance, c++]
excerpt: "The post covers the basic option pricing theory and a prototype of a random number generator class."
mathjax: "true"
---

In this series of blog entries I will describe my progress towards building a versatile yet compact option pricing system in C++. I will follow closely a book by Mark Joshi [C++ Design Patterns and Derivatives Pricing](https://www.amazon.com/Patterns-Derivatives-Pricing-Mathematics-Finance/dp/0521721628). I will use this book as a guideline but at the same time I will try to extend and polish things that were treated vaguely in the book. Thus, I will include numerous other sources and references.  
{: .text-justify}

I will start by covering the very basics of modelling the stock price evolution. The evolution usually involves a drift component that represents steady growth over time with some diffusion component that represents the random deviation from the drift. If the financial underlying could be modelled without a stochastic component then there would not be a reason for quantitative finance to exist in and even if so then not to its current extent. One of the simplest random processes that satisfies the mentioned conditions is the Arithmetic Brownian Motion. If we denote our random process by $$X$$ then if this process follows Arithmetic Brownian Motion it would be specified by the following SDE: 
{: .text-justify}

$$dX(t) = \mu dt + \sigma dB(t)$$

where both $$\mu$$ and $$\sigma$$ are constant and greater than zero. The solution to the SDE is given by 
{: .text-justify}

$$S(T) =  X(0) + \mu T + \sigma B(T)$$

Thus, $$S(T)$$ is equal to the deterministic term $$X(0) + \mu T$$ and the stochastic term, that is normally distributed random variable $$\sigma B(T)$$. The main drawbacks of Arithmetic Brownian Motion in modelling the stock prices is that first of all it describes the absolute change in value, while investors are rather interested in rate of return. Second of all since $$B(T)$$ is a normal variable therefore, the whole equation can assume negative values, which is impossible in the financial world. This process would be good to describe a variable that grows at constant rate but with the uncertainty of growth increasing with time.
{: .text-justify}

The candidate for an optimal process to describe the behaviour of the stock price would have a fix for the two drawbacks mentioned above. Therefore, the next on the list is the Geometric Brownian Motion (GBM). It is a model for the relative change in a random process. 
{: .text-justify}

$$dX(t) = \mu X(t)dt + \sigma X(t)dB(t)$$

Both the drift coefficient $$\mu X(t)dt$$ and the diffusion coefficient $$\sigma X(t)dB(t)$$ are proportional to the latest known value $$X(t)$$. Thus, both of those elements are continuously changing. The greater the last known value of $$X(t)$$ the greater the drift coefficient, in turn the diffusion coefficient would be greater because the random term is generated by the Brownian motion with the greater variance.
{: .text-justify}

The solution to the GBM, denoted further by $$S$$, is found by following the intuition that if GBM would be deterministic $$\frac{dS(t)}{S(t)}$$ would be the derivative of $$ln[S(t)]$$. Thus using the Ito's Lemma for the natural logarithm of $$S$$ gives
{: .text-justify}

$$d ln[S] = (\mu - \frac{1}{2}\sigma)dt + \sigma dB$$

and then by integrating and taking exponents we get the final expression for $$S(T)$$:
{: .text-justify}

$$S(T) = S(0)*exp[(\mu - \frac{1}{2} * \sigma ^2)T + \sigma B(T)]$$

Geometric Brownian Motion has a cure for the drawbacks of the Arithmetic Brownian Motion applied to the financial modelling problems. Solution to GBM being an exponential cannot become negative. And the GBM variance depends linearly on the level of the variable.
{: .text-justify}

The method for approximating the expected value of some function that involves GBM is called the Monte Carlo method. By using the law of large numbers that tell us that given the sequence of identically distributed independent random variables $$Y_i$$, then with probability one the sequence $$\frac{1}{N} \sum_{i=1}^{N} Y_i$$ converges to $$\mathbf{E} (Y_i)$$. So to get the expected value a random variable $$x$$ form the $$N(0, 1)$$ distribution is to be drawn and then the value of the is function computed. After many repeats, the average of outputs is taken to get the estimate of the expected value.
{: .text-justify}

I will start building the code base by implmenting simple pricer of European option using Monte Carlo. Due to its simplicity as well as possibility to comapre the results with the Black-Scholes closed form solution it will make great test case for the start.
{: .text-justify}

The European option price in the Black-Scholes pricing theory is defined as the
{: .text-justify}

$$exp(-rT) \mathbf{E} (f(S_T))$$

where $$r$$ is defined as the continiously compounding rate of growth of the riskless bond, $$S_T$$ is the price of the underlying at the expiry time $$T$$ and $$f$$ the payoff function. Using the assumption that the price of the underlying follows GBM and noticing that since $$B(t)$$ is a Brownian motion, then $$B(T)$$ is distributed as a Gaussian variable with mean zero and variance $$T$$ the price of the vanilla European option is given as
{: .text-justify}

$$exp(-rT) \mathbf{E} f\{S(0)exp[(\mu - \frac{1}{2} \sigma ^2)T + \sigma \sqrt{T} N(0,1)]\}$$

In the older versions of C++ the pesudorandom number generator was to be implmented by the developer. Since C++11 the language is equipped with pseudorandom number generator provided by package *random*. By importing the random module, one can choose from wide range of ready functions generating the pseudorandom numbers.
{: .text-justify}
